initialize() {
	initializeSLiMOptions(dimensionality="xy");
		
//1. Dictionary of Constants
	defineConstant("TicksPerYear", 12);
	defineConstant("K", 9.75*3);  // carrying-capacity density
	
//2. Set genomic constants
	defineConstant("G", 1e6);   // Genome length 1 Mbp for now
	defineConstant("Mu", 1e-8); // Mutation Rate, 1e-8 for adaptive mutations. Neutral will be added later.
	defineConstant("Re", 1e-8); // Recombination Rate
	// QTL for fresh vs salt water
	initializeMutationType("m1", 0.5, "n", 0.0, 1.0);
	m1.convertToSubstitution = F;	
	initializeGenomicElementType("g1", m1, 1);
	initializeGenomicElement(g1, 0, G-1);
	initializeMutationRate(Mu);
	initializeRecombinationRate(Re);
	
//3. Define maps and spatial constraints
	defineConstant("Coast", "./coos-bay-coastline.png"); // Map 1: Coastline
	defineConstant("Habitat", "./coos-bay-habitat.png"); // Map 2: Habitat for Settlement
	defineConstant("HabitatLimit", "./coos-bay-habitat-limit.png"); // Map 3: Distance limit for settlement
	defineConstant("Salinity", "./coos-bay-salinity.png"); // Map 4: Salinity gradient
	
	// spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SAR*3);
	i1.setInteractionFunction("n", 1.0, SAR);
	i1.setConstraints("both", minAge = settlementAge);
	
	// spatial mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SAR);
	i2.setInteractionFunction("n", 1.0, SAR);
	i2.setConstraints("both", minAge = maturityAge);
}
1 first(){
//1. Add population p1, set its spatial bounds, and set starting positions
	sim.addSubpop("p1", asInteger(K * Width * Height));
	p1.setSpatialBounds(c(0, 0, Width, Height));
	p1.individuals.age = rdunif(StartPop, min=1, max=24);
	p1.individuals.setSpatialPosition(Map2.sampleNearbyPoint(pos, INF, "n", SAS*10));		
}

reproduction() {
//1. choose our nearest neighbor as a mate, within the max distance
	mate = i2.drawByStrength(individual, 1);
	AdjustedFecundity = (Fecundity + p1.spatialMapValue("Salinity", pos)); 	//Adjusted Fecundity has direct relationship with salinity
	PBrood = dnorm(CurrentMonth, PBroodMonth, PBroodSD) * (PBroodMax/dnorm(PBroodMonth, PBroodMonth, PBroodSD));
	if ((mate.size() > 0) & (runif(1) < PBrood) & (nOff>0)) {
		p1.addCrossed(individual, mate, count=rpois(1, AdjustedFecundity));
	}
}	
early() {	
//1. Move all larvae in the ocean
	larvae = p1.subsetIndividuals(maxAge = 1);
	pos = larvae.spatialPosition;
	pos = Map1.sampleNearbyPoint(pos, SJ, "n", SDJ); // SJ represents the standard deviation of settlement
	larvae.setSpatialPosition(pos);

//2. Adjust juvenile fitness based on environment
	for (individual in juveniles){
		pos = individual.spatialPosition;
		salinity_lvl = (p1.spatialMapValue("Salinity", pos)); //Fitness according to salinity levels. Higher survival at mid salinity levels
		salinity_mid = 0.5;
		salinity_sd = 0.6;
		individual.fitnessScaling = individual.fitnessScaling * (dnorm(salinity_lvl, salinity_mid, salinity_sd)/dnorm(salinity_mid, salinity_mid, salinity_sd));
	} //SHORTEN	
//3. move settling juveniles towards habitable area
	for (individual in new_juveniles){
		if ((0.5) >= p1.spatialMapValue("HabitatLimit", position))
			sim.killIndividuals(individual);	
	}	
	step_count = 9;
	for (i in 1:step_count)	{
		pos = new_juveniles.spatialPosition;		
		pos = Map3.sampleNearbyPoint(pos, SJ/(sqrt(9)), "n", SDJ/(sqrt(9))); // SJ represents the standard deviation of settlement
		new_juveniles.setSpatialPosition(pos);
	}	
//4. make juveniles settle to habitable area
	pos = Map2.sampleNearbyPoint(pos, SJ*3, "n", SDJ*3); // SAS represents the standard deviation of settlement	
	new_juveniles.setSpatialPosition(pos);

//5. spatial competition provides density-dependent selection
	i1.evaluate(p1);
	competition = i1.localPopulationDensity(adults);
	// Determine the location in the map to scale the fitness
	adult_local_l = p1.spatialMapValue("habitat", adults.spatialPosition);
	adults.fitnessScaling = 1/(1 + (RHO * competition / adult_local_l));
}
//6. Set mutation effects
mutationEffect(m1) { return 1.0; }

late() {

//1. Scale the fitness of the individuals based on their location in the map
	inds = sim.subpopulations.individuals;
	phenotype_m1 = inds.sumOfMutationsOfType(m1);	// Phenotype of m1 mutations, better in estuary
	environment_m1 = Map4.mapValue(pos);
	inds.fitnessScaling = inds.fitnessScaling * (1+dnorm(phenotype_m1, environment_m1, environment_sd));
	
//3. kill adults close to the maximum lifespan (~10yrs)
	for (individual in p1.individuals){
		age = asInteger(individual.age/TicksPerYear);
		// Test for survival based on the binomial distribution
		if ((rbinom(1, age, 0.98)) < age)
			sim.killIndividuals(individual);
	}
}
RUNTIME late() { 
	sim.simulationFinished();
}