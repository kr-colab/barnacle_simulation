// Keywords: nonWF, non-Wright-Fisher, continuous space, continuous spatial landscape, selfing, spatial competition, spatial mate choice

initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	initializeTreeSeq();
	
	// NOTE: I adjusted K and FECUN so this could run on my machine for troubleshooting, but these need to be adjusted further.
	
	// Some biological constants
	defineConstant("TICKS_PER_YEAR", 4);
	defineConstant("settlementAge", TICKS_PER_YEAR);
	defineConstant("Units_per_KM", 1);
	// TODO: This has to be largely increased, since now it has 10K^2 adults per 10Km x 10Km
	defineConstant("K", 9.75);  // carrying-capacity density
	// Adult mating distance is VERY small, so just scale it by K
	defineConstant("SAS", 9.75);  // sigma_S, the spatial interaction width for Adults Settlement
	defineConstant("SAR", (3.9)/sqrt(K)); //sigma_S, the spatial interaction width for Adult Reproduction
	defineConstant("SJ", 1.9);  // sigma_S, the spatial interaction width for Juvenile Dispersal
	defineConstant("SDJ", 0.975); //sigma_S, the standard deviation of the spatial interation width for Juvenile Dispersal
	
	// Fecundity & Reproduction
	defineConstant("FECUN", 1.0); // mean fecundity times the probability that new offpsring survive to become an adult (therefore, this number is much lower than the actual fecundity)
	defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function
	defineConstant("PBROOD", 0.4); // Proportion of the population brooding, see Berger 2009 Mar Eco

	// Base survival per year
	defineConstant("PSURVIVAL", 0.95);
	
	// Genome
	defineConstant("G", 1e6);   // Genome length 1 Mbp for now
	defineConstant("Mu", 1e-8); // Mutation Rate, 1e-8 for adaptive mutations. Neutral will be added later.
	defineConstant("Re", 1e-8); // Recombination Rate
	// QTL for fresh vs salt water
	initializeMutationType("m1", 0.5, "n", 0.0, 1.0);
	m1.convertToSubstitution = F;	
	initializeGenomicElementType("g1", m1, 1);
	initializeGenomicElement(g1, 0, G-1);
	//initializeMutationRate(0); // Keeping this as 0 for the TreeSequence analysis
	initializeMutationRate(Mu); // Running like this for now to test local adaptation
	initializeRecombinationRate(Re);
	
	// Maps
	// Map 1: Water vs Land for juvenile dispersal
	defineConstant("coast_image", "./coos-bay-coastline.png"); // map file location
	// Map 2: Available habitat for adults
	defineConstant("habitat_image", "./habitat-extended.png"); // map file location
	// Map 3: Grayscale salinity gradient 
	defineConstant("habitat_limit_image", "./habitat-limit.png");
	defineConstant("salinity_gradient_image", "./extreme-salinity.png"); // map file location
	if (!exists("W")) defineConstant("W", (19.5));  // width of the simulated area
	if (!exists("H")) defineConstant("H", (19.5));  // height of the simulated area
	defineConstant("StartPop", asInteger(K*W*H/10));
	
	
	// spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SAR*3);
	i1.setInteractionFunction("n", 1.0, SAR);
	i1.setConstraints("both", minAge = settlementAge + 1);
	
	// spatial mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SAR);
	i2.setInteractionFunction("n", 1.0, SAR);
	i2.setConstraints("both", minAge = settlementAge + 1);
}
1 first(){

//1. Add population p1 and set its spatial bounds
	
	sim.addSubpop("p1", asInteger(StartPop));
	p1.setSpatialBounds(c(0, 0, W, H));
	p1.individuals.age = rdunif(StartPop, min=TICKS_PER_YEAR, max=TICKS_PER_YEAR*8);

	
//2. Process the maps defined in initialize
	// Map 1: Coos bay outline
	map1Image = Image(coast_image);
	map1_vals = 1-map1Image.floatR; // converts the red information of an rgb image to a normalized scale from 0-1
	map1_vals = p1.defineSpatialMap("coastOutline", "xy", map1_vals, // reads the normalized scale (1 is black and 0 is white) so that disperal can
		valueRange=c(0.0, 1.0), colors=c('#FFFFFF', '#000000'));		// be directed towards a high value (1, black) and away from a low value (0, white)
	defineConstant("Map1", map1_vals);
	Map1.rescale(min=1e-7);
	
	// Map 2: Adult settlement habitat
	map2Image = Image(habitat_image);
	map2_vals = 1-map2Image.floatR;
	map2_vals = p1.defineSpatialMap("habitat", "xy", map2_vals, 
		valueRange=c(0.0, 1.0), colors=c('#FFFFFF', '#000000'));
	defineConstant("Map2", map2_vals);
	Map2.rescale(min=1e-7);
	
	// Map 3: Adult settlement limit
	map3Image = Image(habitat_limit_image);
	map3_vals = (1-map3Image.floatR); // *(1.0-0.0);	
	map3_vals = p1.defineSpatialMap("habitatLimit", "xy", map3_vals,
		valueRange=c(0.0, 0.5), colors=c('#FFFFFF', '#000000'));
	defineConstant("Map3", map3_vals);
	Map3.rescale(min=1e-7);
	
	// Map 4: Map of salinity
	map4Image = Image(salinity_gradient_image);
	map4_vals = 1-map4Image.floatR;
	map4_vals = p1.defineSpatialMap("salinity", "xy", map4_vals, 
		valueRange=c(0.0,1.0), colors=c('#FFFFFF', '#000000'));
	defineConstant("Map4", map4_vals);
	//	Map4.rescale(min=1e-7);
	
//3. Set starting point for initial population
	//a. Focused starting point for testing dispersal
	// for (ind in p1.individuals) {
		//ind.x = rnorm(1, 16.575, 0.25);
		//ind.y = rnorm(1, 9.75, 0.25);
	//}	
		
	//b. Starting near settlement habitat (as if spawned by adults)	
	ind = p1.individuals;
	pos = ind.spatialPosition;	
	pos = Map2.sampleNearbyPoint(pos, INF, "n", SAS*10);	
	ind.setSpatialPosition(pos);
}
1 early() {	
}

first() {
	// look for mates
	i2.evaluate(p1);
	
	// move all juveniles in the ocean
	step_count = 10;
	juveniles = p1.subsetIndividuals(maxAge = settlementAge - 1);
	pos = juveniles.spatialPosition;
	for (i in 1:step_count)	
		pos = Map1.sampleNearbyPoint(pos, SJ/(sqrt(10)), "n", SDJ/(sqrt(10))); // SJ represents the standard deviation of settlement
	juveniles.setSpatialPosition(pos);

}

reproduction() {
	// choose our nearest neighbor as a mate, within the max distance. This is where I added in the code from BarnaclesInTheOcean.slim
	mate = i2.drawByStrength(individual, 1);
	pos = individual.spatialPosition;
	adjustedFecundity = FECUN + p1.spatialMapValue("salinity", pos);
	nOff = rpois (1, adjustedFecundity);
	if ((mate.size() > 0) & (runif(1) < PBROOD) & (nOff>0)) {
		p1.addCrossed(individual, mate, count=nOff);
	}
}	

	//TODO: Organize steps in order: early (1. reproduction, 2. dispersal, 3. settlement (using smoothed map), [simulate density map?]), late (4. adult competition, 5. juvenile death due to environment, 6. adult death due to age)

early() {

	// Adjust fitness of individuals based on their environment
	juveniles = p1.subsetIndividuals(maxAge = settlementAge - 1);	
	for (individual in juveniles){
		pos = individual.spatialPosition;
		salinity_lvl = (p1.spatialMapValue("salinity", pos));
		// Fitness according to salinity levels. Higher survival at mid salinity levels
		salinity_mid = 0.5;
		salinity_sd = 0.6;
		individual.fitnessScaling = individual.fitnessScaling * (dnorm(salinity_lvl, salinity_mid, salinity_sd)/dnorm(salinity_mid, salinity_mid, salinity_sd));
	}
	
	// make new adults settle to habitable area
	new_adults = p1.subsetIndividuals(minAge = settlementAge, maxAge = settlementAge);
	for (individual in new_adults){
		pos = individual.spatialPosition;
		if ((1) > p1.spatialMapValue("habitatLimit", pos))
				sim.killIndividuals(individual);
	}	
	// set settlement positions of the new adults
	pos = new_adults.spatialPosition;
	pos = Map2.sampleNearbyPoint(pos, SJ*10, "n", SAS); // SAS represents the standard deviation of settlement	
	new_adults.setSpatialPosition(pos);
	
	//TODO: set a lower maxdistance, adjust habitat limit map or max distance

	
	// spatial competition provides density-dependent selection
	i1.evaluate(p1);
	// Add an if statement so the fitness reductions is only in adults, aka juveniles are floating around and do not compete with the adults
	adults = p1.subsetIndividuals(minAge = settlementAge);
	competition = i1.localPopulationDensity(adults);
	// Determine the location in the map to scale the fitness
	adult_local_l = p1.spatialMapValue("habitat", adults.spatialPosition);
	adults.fitnessScaling = 1/(1 + (RHO * competition / adult_local_l));
	
	
	// Set colors for reference
	young_juveniles = p1.subsetIndividuals(minAge = 0, maxAge = 1);
	mid_juveniles = p1.subsetIndividuals(minAge = 2, maxAge = 2);
	old_juveniles = p1.subsetIndividuals(minAge = 3, maxAge = settlementAge-1);
	young_adults = p1.subsetIndividuals(minAge = settlementAge, maxAge = 4*settlementAge);
	old_adults = p1.subsetIndividuals(minAge = (4*settlementAge)+1);
	young_juveniles.color = "red";
	mid_juveniles.color = "orange";
	old_juveniles.color = "yellow";
	young_adults.color = "green";
	//old_adults.color = "blue";	

	
}

mutationEffect(m1) { return 1.0; }

late() {
	
	// Scale the fitness of the individuals based on their location in the map
	inds = sim.subpopulations.individuals;
	pos = inds.spatialPosition;
	// Phenotype of m1 mutations
	phenotype_m1 = inds.sumOfMutationsOfType(m1);
	environment_m1 = Map4.mapValue(pos);
	// TODO: Adjust SD for the environment landscape. What should it be?
	environment_sd = 0.001;
	inds.fitnessScaling = inds.fitnessScaling * (dnorm(phenotype_m1, environment_m1, environment_sd));
	
	// Kill individuals based on age
	// TODO: Is this correct?
	for (individual in p1.individuals){
		age = asInteger(individual.age/TICKS_PER_YEAR);
		// Test for survival based on the binomial distribution
		if ((rbinom(1, age, PSURVIVAL)) < age)
			sim.killIndividuals(individual);
	}

	// Density map (when I want to add back in
	density=summarizeIndividuals(p1.individuals, c(25,25), p1.spatialBounds, operation="individuals.size();",
		empty=0.0, perUnitArea=T);
	p1.defineSpatialMap("density", "xy", density, T, c(0,K), colors(20, "viridis"));	

}

2000 late() { 
	//sim.treeSeqOutput("./Week 5/balGla_5-1.trees");
	catn("Done.");
	sim.simulationFinished();
}


	
	// density map coloration options: "cm", "heat", "terrain"; parula", "hot", "jet", 
	// "turbo", "gray"; "magma", "inferno", "plasma", "viridis", and "cividis" 	