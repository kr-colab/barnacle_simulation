// Keywords: nonWF, non-Wright-Fisher, continuous space, continuous spatial landscape, selfing, spatial competition, spatial mate choice

initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	initializeTreeSeq();
	
	// NOTE: I adjusted K and FECUN so this could run on my machine for troubleshooting, but these need to be adjusted further.
	
	// Some biological constants
	defineConstant("TICKS_PER_YEAR", 3);
	defineConstant("settlementAge", TICKS_PER_YEAR);
	// TODO : find out conversion between pixel to Km
	// TODO: This has to be largely increased, since now it has 10K^2 adults per 10Km x 10Km
	defineConstant("K", 25);  // carrying-capacity density
	// Adult mating distance is VERY small, so just scale it by K
	defineConstant("SAS", 5.0*2);  // sigma_S, the spatial interaction width for Adults Settlement
	defineConstant("SAR", (1.0*2)/sqrt(K)); //sigma_S, the spatial interaction width for Adult Reproduction
	defineConstant("SJ", 10.0*2);  // sigma_S, the spatial interaction width for Juvenile Dispersal
	
	// Fecundity & Reproduction
	defineConstant("FECUN", 1.); // mean fecundity times the probability that new offpsring survive to become an adult (therefore, this number is much lower than the actual fecundity)
	defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function
	defineConstant("PBROOD", 0.4); // Proportion of the population brooding, see Berger 2009 Mar Eco
	
	// Genome
	defineConstant("G", 1e6);   // Genome length 1 Mbp for now
	//defineConstant("Mu", 1e-8); // Mutation Rate
	defineConstant("Re", 1e-8); // Recombination Rate
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, G-1);
	initializeMutationRate(0); // Keeping this as 0 for the TreeSequence analysis
	initializeRecombinationRate(Re);
	
	// Maps
	// Map 1: Water vs Land for juvenile dispersal
	defineConstant("coast_image_location", "./coos-bay-coast.png"); // map file location
	// Map 2: Available habitat for adults
	defineConstant("habitat_image_location", "./coos-bay-habitat-extended.png"); // map file location
	if (!exists("W")) defineConstant("W", (10.80*2));  // width of the simulated area
	if (!exists("H")) defineConstant("H", (10.80*2));  // height of the simulated area
	
	
	// spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SAR*3);
	i1.setInteractionFunction("n", 1.0, SAR);
	i1.setConstraints("both", minAge = settlementAge + 1);
	
	// spatial mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SAR);
	i2.setInteractionFunction("n", 1.0, SAR);
	i2.setConstraints("both", minAge = settlementAge + 1);
}
1 first() {
	sim.addSubpop("p1", asInteger(K * W * H / (100*4)));
	p1.setSpatialBounds(c(0, 0, W, H));
	p1.individuals.setSpatialPosition(p1.pointUniform(asInteger(K * W * H / (100*4))));
	
	// Process the maps
	// Map 1:
	map1Image = Image(coast_image_location);
	map1_vals = 1-map1Image.floatR;
	map1_vals = p1.defineSpatialMap("water", "xy", map1_vals,
		valueRange=c(0.0, 1.0), colors=c('#FFFFFF', '#000000'));
	defineConstant("Map1", map1_vals);
	Map1.rescale(min=1e-7);
	
	// Map 2:
	map2Image = Image(habitat_image_location);
	map2_vals = 1-map2Image.floatR;
	map2_vals = p1.defineSpatialMap("habitat", "xy", map2_vals,
		valueRange=c(0.0, 1.0), colors=c('#FFFFFF', '#000000'));
	defineConstant("Map2", map2_vals);
	Map2.rescale(min=1e-7);
}

first() {
	// look for mates
	i2.evaluate(p1);
}

reproduction() {
	// choose our nearest neighbor as a mate, within the max distance. This is where I added in the code from BarnaclesInTheOcean.slim
	mate = i2.drawByStrength(individual, 1);
	nOff = rpois (1, FECUN);
	if ((mate.size() > 0) & (runif(1) < PBROOD) & (nOff>0)) {
		for (i in seqLen(nOff)) {
			pos = Map1.sampleNearbyPoint(individual.spatialPosition, SAR, "n", SAR/2);			
			//pos = individual.spatialPosition + rnorm(2, 0, SD);
			p1.addCrossed(individual, mate, count=1);
		
		}
	}
}	
// old reproduction code in case we need it
	//mate = i2.nearestInteractingNeighbors(individual, 1);
	//offspring_count = rpois(1, FECUN);
	//if ((mate.size() > 0) & (runif(1) < PBROOD) & (offspring_count>0))
		//p1.addCrossed(individual, mate, count=rpois(1, offspring_count));
		
early() {
	// move all juveniles in the ocean
	juveniles = p1.subsetIndividuals(maxAge = settlementAge - 1);
	pos = juveniles.spatialPosition;
	pos = Map1.sampleNearbyPoint(pos, INF, "n", SJ); // SJ represents the standard deviation of settlement
	juveniles.setSpatialPosition(pos);
	
	// make new adults settle to habitable area
	new_adults = p1.subsetIndividuals(minAge = settlementAge, maxAge = settlementAge);
	// set settlement positions of the new adults
	pos = new_adults.spatialPosition;
	pos = Map2.sampleNearbyPoint(pos, SJ, "n", SAS); // SAS represents the standard deviation of settlement
	new_adults.setSpatialPosition(pos);
	// spatial competition provides density-dependent selection
	i1.evaluate(p1);
	// Add and if statement so the fitness reductions is only in adults, aka juveniles are floating around and do not compete with the adults
	adults = p1.subsetIndividuals(minAge = settlementAge);
	competition = i1.localPopulationDensity(adults);
	// Determine the location in the map to scale the fitness
	adult_local_l = p1.spatialMapValue("habitat", adults.spatialPosition);
	adults.fitnessScaling = 1/(1 + (RHO * competition / adult_local_l));
	adults.color = "yellow";
	juveniles.color = "red";	
	
	// Density map, was thinking to only track adults or only track juveniles, but ran into issues replacing p1.individuals in line 126 
	density=summarizeIndividuals(p1.individuals, c(25,25), p1.spatialBounds, operation="individuals.size();", empty=0.0, perUnitArea=T);
	p1.defineSpatialMap("density", "xy", density, T, c(0,K), colors(20,"heat"));	
	
	// kill adults close to the maximum lifespan (~10yrs)
	inds = p1.individuals;
	ages = inds.age;
	inds8 = inds[(ages >= (8*TICKS_PER_YEAR)) & (ages < (9*TICKS_PER_YEAR))];
	inds9 = inds[(ages >= (9*TICKS_PER_YEAR)) & (ages < (10*TICKS_PER_YEAR))];
	inds10 = inds[ages >= (10*TICKS_PER_YEAR)];
	death8 = (runif(inds8.size()) < 0.10);
	death9 = (runif(inds9.size()) < 0.30);
	death10 = (runif(inds10.size()) < 0.95);
	sim.killIndividuals(c(inds8[death8], inds9[death9], inds10[death10]));
}
300 late() { }
